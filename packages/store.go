package packages

import (
	"bytes"
	"strings"
)

var (
	entityCreatorProperties = map[string]bool{
		"createdByFirstName": true,
		"createdBySurname":   true,
		"updatedByFirstName": true,
		"updatedBySurname":   true,
	}
)

// Service defines an injected service into the Store object.
type Service struct {
	name        string
	packageName string
}

// Store data store entity structure.
type Store struct {
	_package   *Package
	imports    []*Import
	mainEntity *Entity
	services   []*Service
	// properties          []*Property
	methods             []*Function
	structName          string
	variableName        string
	hasPrivateNewMethod bool
	hasPublicNewMethod  bool
	hasBuildQueriesFunc bool
}

// VariableName returns a variable name the store uses in method bodies.
func (store *Store) VariableName() string {
	if store.variableName == "" {
		store.variableName = lowerFirst(store.structName)
	}
	return store.variableName
}

// ContainsFetchMethod if the fetch method is already known in the store.
func (store *Store) ContainsFetchMethod() bool {
	for _, method := range store.methods {
		if method.name == "fetch" {
			return true
		}
	}
	return false
}

// HasBuildQueriesFunc if the method is already present on the store struct.
func (store *Store) HasBuildQueriesFunc() bool {
	return store.hasBuildQueriesFunc
}

func (store *Store) addImport(imp *Import) {
	for i := range store.imports {
		if store.imports[i].path == imp.path {
			return
		}
	}
	store.imports = append(store.imports, imp)
}

// BuildFileOutput constructs the full synthesized file output for the current store.
func (store *Store) BuildFileOutput() ([]byte, error) {
	output := bytes.NewBufferString("// Code generated by espal-store-synthesizer. DO NOT EDIT.\n")
	output.WriteString("package " + store._package.name + "\n\n")

	if len(store.imports) > 0 {
		output.WriteString("import (\n")
		for _, importChunk := range store.imports {
			output.WriteString("\t" + `"` + importChunk.path + `"` + "\n")
		}
		output.WriteString(")\n\n")
	}

	output.WriteString("var _ Store = &" + store.structName + "{}\n\n")

	output.WriteString("// Store represents a data interaction object.\n")
	output.WriteString("type Store interface {\n")
	for _, method := range store.methods {
		output.WriteString("\t" + method.name + "(")
		var firstHad bool
		for _, parameter := range method.parameters {
			if firstHad {
				output.WriteString(", ")
			} else {
				firstHad = true
			}
			output.WriteString(parameter.name + " " + parameter._type)
		}
		output.WriteString(")")
		printWrappingParentheses := len(method.returnValues) > 1 || method.ContainsNamedReturnValue()
		if printWrappingParentheses {
			output.WriteString(" (")
		} else if len(method.returnValues) > 0 {
			output.WriteString(" ")
		}
		firstHad = false
		for _, returnValue := range method.returnValues {
			if firstHad {
				output.WriteString(", ")
			} else {
				firstHad = true
			}
			if returnValue.name == "" {
				output.WriteString(returnValue._type)
			} else {
				output.WriteString(returnValue.name + " " + returnValue._type)
			}
		}
		if printWrappingParentheses {
			output.WriteString(")")
		}
		output.WriteString("\n")
	}
	// TODO :: 7777 Also loop Public methods here that are created later (GetOne, etc.)
	output.WriteString("}\n")

	if !store.ContainsFetchMethod() {
		output.WriteString("\n")
		// #STRUCT_VAR_NAME			users
		// #STRUCT_NAME				Users
		// #ENTITY_STRUCT_NAME		User
		// #ENTITY_STRUCT_INTERFACE	User
		// #ENTITY_STRUCT_VAR_NAME  user
		// #ENTITY_FIELDS			a, b, c
		// #ENTITY_CREATOR_FIELDS	d, e, f
		// TODO :: Should not accidentally link fields that aren't DB-fields (extra struct fields)
		entityFields := strings.Builder{}
		var firstHad bool
		for _, property := range store.mainEntity.properties {
			if _, ok := entityCreatorProperties[property.Name()]; ok {
				continue
			}
			if strings.Contains(property.Comment(), "@synthesize-no-db-field") {
				continue
			}
			if firstHad {
				entityFields.WriteString(", ")
			}
			entityFields.WriteString("&" + store.mainEntity.VariableName() + "." + property.Name())
			firstHad = true
		}
		firstHad = false
		creatorFields := strings.Builder{}
		for _, property := range store.mainEntity.properties {
			if _, ok := entityCreatorProperties[property.Name()]; !ok {
				continue
			}
			if firstHad {
				creatorFields.WriteString(", ")
			}
			creatorFields.WriteString("&" + store.mainEntity.VariableName() + "." + property.Name())
			firstHad = true
		}

		replacer := strings.NewReplacer([]string{
			"#STRUCT_VAR_NAME", store.VariableName(),
			"#STRUCT_NAME", store.structName,
			"#ENTITY_STRUCT_NAME", store.mainEntity.Name(),
			"#ENTITY_STRUCT_INTERFACE", store.mainEntity.interfaceName,
			"#ENTITY_STRUCT_VAR_NAME", store.mainEntity.VariableName(),
			"#ENTITY_FIELDS", entityFields.String(),
			"#ENTITY_CREATOR_FIELDS", creatorFields.String(),
		}...)
		output.WriteString(replacer.Replace(fetchModel))
	}

	if !store.hasPublicNewMethod {
		output.WriteString("\n")
		output.WriteString("// New returns a new instance of " + store.structName + ".\n")
		output.WriteString("func New(")
		var firstHad bool
		for _, service := range store.services {
			if firstHad {
				output.WriteString(", ")
			}
			output.WriteString(service.name)
			output.WriteString(" ")
			output.WriteString(service.packageName)
			if !firstHad {
				firstHad = true
			}
		}
		output.WriteString(") (*" + store.structName + ", error) {\n")
		output.WriteString("\t" + store.variableName + " := &" + store.structName + "{")
		if len(store.services) > 0 {
			output.WriteString("\n")
			// Do pretty indenting just like the formatter
			var longestServiceName int
			for _, service := range store.services {
				if len(service.name) > longestServiceName {
					longestServiceName = len(service.name)
				}
			}
			for _, service := range store.services {
				output.WriteString("\t\t")
				output.WriteString(service.name)
				output.WriteString(": ")
				if len(service.name) < longestServiceName {
					output.WriteString(strings.Repeat(" ", longestServiceName-len(service.name)))
				}
				output.WriteString(service.name)
				output.WriteString(",\n")
			}
			output.WriteString("\t")
		}

		output.WriteString("}\n")
		// Call buildQueries if it's present
		if store.HasBuildQueriesFunc() {
			output.WriteString("\tif err := " + store.variableName + ".buildQueries(); err != nil {\n")
			output.WriteString("\t\t return nil, errors.Trace(err)\n")
			output.WriteString("}\n")
		}
		output.WriteString("\treturn " + store.variableName + ", nil\n")
		output.WriteString("}\n")

		// TODO :: Activate when actual tests are being added
		// if err := ioutil.WriteFile(strings.Replace(entry, ".go", "", 1)+"_synthesized_test.go", testOutput.Bytes(), 0644); err != nil {
		// 	return errors.Trace(err)
		// }
	}

	return output.Bytes(), nil
}

// BuildTestFileOutput constructs the full synthesized test file output for the current entity.
func (store *Store) BuildTestFileOutput() ([]byte, error) {
	output := bytes.NewBufferString("// Code generated by espal-store-synthesizer. DO NOT EDIT.\n")

	// TODO :: 777777 Implement

	return output.Bytes(), nil
}
